```{julia}
ty, tX = y[idx], X[idx,available_variables]

thr = LinRange(0.0, 1.0, 350)
C = zeros(ConfusionMatrix, (k, length(thr)))
for (j,fold) in enumerate(folds)
    trn, vld = fold
    foldmodel = naivebayes(ty[trn], tX[trn,:])
    foldvalid = vec(mapslices(foldmodel, tX[vld,:]; dims=2))
    for (i,t) in enumerate(thr)
        C[j,i] = ConfusionMatrix(foldvalid, ty[vld], t)
    end
end
```

performance curve

```{julia}
fig = Figure(; resolution=(900, 450))

ax_mcc = Axis(fig[1,1])

scores = mcc.(C)
σ = vec(std(scores; dims=1))
μ = vec(mean(scores; dims=1))

band!(ax_mcc, thr, μ-σ, μ+σ, color=:lightgrey)

lines!(ax_mcc, thr, μ, color=:black, linewidth=3)

xlims!(ax_mcc, low=0.0, high=1.0)
ylims!(ax_mcc, low=0.0, high=1.0)

_, m = findmax(μ)
vlines!(ax_mcc, thr[m])


ax_roc = Axis(fig[1,2])

for i in axes(C, 1)
    lines!(ax_roc, fpr.(C[i,:]), tpr.(C[i,:]), color=:lightgrey)
end

xlims!(ax_roc, low=0.0, high=1.0)
ylims!(ax_roc, low=0.0, high=1.0)


current_figure()
```

retrain

```{julia}
model2 = naivebayes(ty, tX)
```

performance on the testing data

```{julia}
yhat = vec(mapslices(model2, X[tidx,available_variables]; dims=2))
C = ConfusionMatrix(yhat, y[tidx], thr[m])
@info mcc(C)
@info accuracy(C)
@info fpr(C)
@info fnr(C)
@info tpr(C)
@info tnr(C)
```

we make a map

```{julia}
predictors = [SpeciesDistributionToolkit._read_geotiff("artifacts/layers.tiff", SimpleSDMResponse; bandnumber=i) for i in axes(X, 2)]
prediction = similar(first(predictors))
Threads.@threads for k in keys(prediction)
    prediction[k] = model2([p[k] for p in predictors[available_variables]])
    if isnan(prediction[k])
        prediction[k] = 0.0
    end
end
```

map the prediction

```{julia}
fig = Figure(; resolution=(900, 400))
ax = Axis(fig[1,1]; xlabel="Longitude", ylabel="Latitude", aspect=DataAspect())
hm = heatmap!(ax, prediction, colormap=Reverse(:curl), colorrange=(0., 1.))
Colorbar(fig[1,2], hm; tellheight=false)
current_figure()
```

uncertainty

```{julia}
function entropy(f)
    p = [f, 1-f]
    return -sum(p .* log2.(p))
end

fig = Figure(; resolution=(900, 400))
ax = Axis(fig[1,1]; xlabel="Longitude", ylabel="Latitude", aspect=DataAspect())
hm = heatmap!(ax, entropy.(prediction), colormap=Reverse(:tokyo), colorrange=(0., 1.))
Colorbar(fig[1,2], hm; tellheight=false)
current_figure()
```

shapley values

```{julia}
shapval = [similar(first(predictors)) for i in eachindex(available_variables)]
Threads.@threads for k in keys(shapval[1])
    x = [p[k] for p in predictors[available_variables]]
    for i in axes(shapval, 1)
        shapval[i][k] = shapleyvalues(model2, tX, x, i; M=50)
        if isnan(shapval[i][k])
            shapval[i][k] = 0.0
        end
    end
end
```

map

```{julia}
fig = Figure(; resolution=(900, 800))

gl = fig[1,1] = GridLayout()

for i in 1:3
    ax_mp = Axis(gl[i,1])
    scl = maximum(abs.(extrema(shapval[i]))).*(-1,1)
    heatmap!(ax_mp, shapval[i], colorrange=scl, colormap=:cork, aspect=DataAspect())
    hidexdecorations!(ax_mp)
    hideydecorations!(ax_mp)

    ax_pr = Axis(gl[i,2], title=list_of_variables[available_variables[i]][1])
    ylims!(ax_pr, scl)
    hexbin!(ax_pr, predictors[available_variables[i]], shapval[i], bins=200)
end

#rowgap!(gl, 10.0)

current_figure()
```

mosaic of most important variable in the top 4

```{julia}
heatmap(mosaic(argmax, map(abs, shapval)), colormap=:Set2_4)
```

test

```{julia}
fig = Figure()

ax2 = GeoAxis(fig[1, 1], dest = "+proj=natearth2", coastlines = false, lonlims=extrema(longitudes(shapval[1])), latlims=extrema(latitudes(shapval[1])))

surface!(ax2, shapval[2]; shading = false, colormap = :curl)
tightlimits!(ax2)

current_figure()
```